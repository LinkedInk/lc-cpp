#include "pasta\headers.cpp"

class Solution {
public:
    // given an array of nums without 0, the biggest absolute subarray product includes every single number
    // to get the biggest positive when the total product is negative, one negative number must be removed
    // this splits the subarray into 2 (perhaps 1 with 0 elements), and the biggest subarray product must be on either side
    // therefore, the subarray must include one of the ends of the array, ie the subarray must be a prefix of suffix
    // this solution simply resets the calculation when a 0 is met.
    int maxProduct(vector<int>& nums) {
        int res = nums[0];
        int prefix = 0, suffix = 0;

        loopi(i, 0, nums.size()) {
            prefix = nums[i] * (prefix == 0 ? 1 : prefix);
            suffix = nums[nums.size() - 1 - i] * (suffix == 0 ? 1 : suffix);
            res = max(res, max(prefix, suffix));
        }
        return res;
    }

    // for every next number, starting with the first, decisions have to be made
    // does the new element join the subarray on the that ends next to it?
    // what is the biggest and smallest subarray on the left that ends next to it?
    // if it joins, what is now the biggest and smallest product value?
    // if it starts a new subarray, is it bigger/maller than the values generated by joining?
    int maxProduct1(vector<int>& nums) {
        int res = nums[0];
        int curMin = 1, curMax = 1;

        for (int num : nums) {
            int tmp = curMax * num;
            curMax = max(max(num * curMax, num * curMin), num);
            curMin = min(min(tmp, num * curMin), num);
            res = max(res, curMax);
        }
        return res;
    }
};